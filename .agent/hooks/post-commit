#!/bin/bash
# ADR-002: Auto-ingest committed files into Pixeltable memory
# Installed by: scripts/install_hooks.sh
#
# This hook runs after each commit and ingests documentation files
# into the organizational knowledge base for context retrieval.

set -euo pipefail

PROJECT_ROOT="$(git rev-parse --show-toplevel)"
STATE_DIR="${PROJECT_ROOT}/.agent/state"
LOG_FILE="${PROJECT_ROOT}/.agent/logs/ingestion.log"

# Use project venv Python (critical for environment isolation)
PYTHON="${PROJECT_ROOT}/.venv/bin/python"
if [ ! -f "$PYTHON" ]; then
    PYTHON="python3"  # Fallback
fi

# Ensure directories exist
mkdir -p "$STATE_DIR" "$(dirname "$LOG_FILE")"

# Get files changed in this commit
COMMIT_SHA=$(git rev-parse HEAD)
CHANGED_FILES=$(git diff-tree --no-commit-id --name-only --diff-filter=AMR -r HEAD)

# Filter to ingestible files (allowlist)
INGESTIBLE_PATTERNS="\.md$|\.txt$|\.rst$|docs/|adr/|ADR-"
EXCLUDED_PATTERNS="node_modules/|\.venv/|dist/|build/|__pycache__/"

# Additional secrets protection
SECRETS_PATTERNS="\.env|secret|\.key$|\.pem$|password|token|credential"

FILES_TO_INGEST=""
while IFS= read -r file; do
    [ -z "$file" ] && continue

    # Check if file matches ingestible patterns
    if ! echo "$file" | grep -qE "$INGESTIBLE_PATTERNS"; then
        continue
    fi

    # Check if file matches excluded patterns
    if echo "$file" | grep -qE "$EXCLUDED_PATTERNS"; then
        continue
    fi

    # Check if file matches secrets patterns
    if echo "$file" | grep -qiE "$SECRETS_PATTERNS"; then
        echo "[post-commit] SKIPPED sensitive file: $file" >> "$LOG_FILE"
        continue
    fi

    FILES_TO_INGEST="${FILES_TO_INGEST}${file}"$'\n'
done <<< "$CHANGED_FILES"

# Remove trailing newline and check if empty
FILES_TO_INGEST=$(echo "$FILES_TO_INGEST" | sed '/^$/d')

if [ -z "$FILES_TO_INGEST" ]; then
    echo "[post-commit] No ingestible files in commit, skipping."
    exit 0
fi

FILE_COUNT=$(echo "$FILES_TO_INGEST" | wc -l | tr -d ' ')
echo "[post-commit] Ingesting $FILE_COUNT files..."

# Run ingestion asynchronously to not block commit
(
    cd "$PROJECT_ROOT"

    # Log start
    echo "$(date -Iseconds) | COMMIT=$COMMIT_SHA | START | files=$FILE_COUNT" >> "$LOG_FILE"

    # Security: Write files to a temp file to avoid shell injection via filenames
    TEMP_FILE=$(mktemp)
    echo "$FILES_TO_INGEST" > "$TEMP_FILE"

    # Ingest files using Python script that reads from temp file (no shell interpolation)
    "$PYTHON" <<PYTHON_SCRIPT >> "$LOG_FILE" 2>&1
import os
import sys

# Read files from temp file (avoids shell injection)
temp_file = "$TEMP_FILE"
commit_sha = "$COMMIT_SHA"

try:
    from src.workflows.ingestion import ingest_file

    with open(temp_file, 'r') as f:
        files = [line.strip() for line in f if line.strip()]

    for file_path in files:
        if os.path.isfile(file_path):
            result = ingest_file(file_path, commit_sha=commit_sha)
            status = 'OK' if result.get('success') else result.get('reason', 'FAILED')
            print(f"  {result.get('path', file_path)}: {status}")
except Exception as e:
    print(f"ERROR: {e}", file=sys.stderr)
    sys.exit(1)
PYTHON_SCRIPT

    # Cleanup temp file
    rm -f "$TEMP_FILE"

    # Record success
    echo "$COMMIT_SHA" > "$STATE_DIR/last_ingest_sha"
    echo "$(date -Iseconds) | COMMIT=$COMMIT_SHA | SUCCESS" >> "$LOG_FILE"
) &

echo "[post-commit] Ingestion queued. Check .agent/logs/ingestion.log for status."
